<script>
        let currentSearchType = '{{.SearchType}}' || 'pages';
        let searchTimeout;
        let showPosts = false;
        let sortByTime = false;
        
        const initialState = document.getElementById('initial-state');
        const searchState = document.getElementById('search-state');
        const initialSearch = document.getElementById('initial-search');
        const searchInput = document.getElementById('search-input');
        const loadingDiv = document.getElementById('loading');
        const resultsDiv = document.getElementById('results');

        // Custom RSS Builder Variables
        let rssNodes = new Map();
        let rssConnections = [];
        let selectedNode = null;
        let nodeIdCounter = 1;
        let isDraggingNode = false;
        let dragOffset = { x: 0, y: 0 };
        let isConnecting = false;
        let connectionStart = null;
        const canvas = document.getElementById('rss-canvas');
        const customRSSBuilder = document.getElementById('custom-rss-builder');
        
        // Zoom functionality
        let zoomLevel = 1;
        let canvasScale = 1;
        
        // Canvas panning functionality
        let canvasOffset = { x: 0, y: 0 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        const minZoom = 0.25;
        const maxZoom = 3;
        const zoomStep = 0.25;

        // Handle initial search
        if (initialSearch) {
            initialSearch.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const query = this.value.trim();
                    if (query) {
                        switchToSearchState(query);
                        performSearch();
                    }
                }
            });
        }

        // Handle search state search
        if (searchInput) {
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                if (this.value.trim() === '') return;
                
                searchTimeout = setTimeout(() => {
                    performSearch();
                }, 500);
            });

            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                }
            });
        }

        // Handle type tab clicks (both initial and search state)
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('type-tab') || e.target.classList.contains('type-tab-large')) {
                const type = e.target.dataset.type;
                currentSearchType = type;
                
                // Update active state
                const container = e.target.parentElement;
                container.querySelectorAll('.type-tab, .type-tab-large').forEach(tab => {
                    tab.classList.remove('active');
                });
                e.target.classList.add('active');
                
                // Update filter visibility based on search type
                updateFilterVisibility();
                updateCustomRSSVisibility();
                
                // If we have a search query, perform search
                const query = (searchInput?.value || initialSearch?.value || '').trim();
                if (query) {
                    if (initialState && initialState.style.display !== 'none') {
                        switchToSearchState(query);
                    }
                    performSearch();
                }
            }
        });

        // Handle filter changes
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('filter-select')) {
                const query = searchInput?.value?.trim();
                if (query) {
                    performSearch();
                }
            }
        });

        function switchToSearchState(query) {
            if (initialState) initialState.style.display = 'none';
            if (searchState) searchState.style.display = 'block';
            if (searchInput) searchInput.value = query;
            
            // Update search state type tabs
            document.querySelectorAll('#search-state .type-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === currentSearchType);
            });
            
            // Update filter visibility
            updateFilterVisibility();
        }

        function performSearch() {
            const query = (searchInput?.value || initialSearch?.value || '').trim();
            if (!query) return;

            if (loadingDiv) loadingDiv.style.display = 'block';
            if (resultsDiv) resultsDiv.innerHTML = '';

            const params = new URLSearchParams({
                qry: query,
                type: currentSearchType,
                content: document.getElementById('content-filter')?.value || '',
                time: document.getElementById('time-filter')?.value || ''
            });
            
            // Add include_posts parameter for RSS feeds when toggle is enabled
            if (currentSearchType === 'sites' && showPosts) {
                params.set('include_posts', 'true');
            }
            
            // Add sort parameter for posts
            if (currentSearchType === 'pages' && sortByTime) {
                params.set('sort', 'time');
            }
            
            fetch('/api/search?' + params.toString())
                .then(response => response.json())
                .then(data => {
                    if (loadingDiv) loadingDiv.style.display = 'none';
                    displayResults(data);
                    updateURL(params);
                })
                .catch(error => {
                    if (loadingDiv) loadingDiv.style.display = 'none';
                    console.error('Search error:', error);
                    if (resultsDiv) resultsDiv.innerHTML = '<div class="no-results">Search failed. Please try again.</div>';
                });
        }

        function displayResults(data) {
            if (!resultsDiv) return;
            
            if (data.results && data.results.length > 0) {
                // Check if we should hide RSS link for feeds search
                const hideRss = currentSearchType === 'sites';
                const headerClass = hideRss ? 'results-header hide-rss' : 'results-header';
                
                let html = '<div class="' + headerClass + '">' +
                          '<div class="results-stats">About ' + 
                          data.total_results + ' results (' + data.time_taken.toFixed(2) + ' seconds)</div>' +
                          '<a href="#" id="rss-feed-link" class="rss-feed-link" onclick="openRSSFeed()" title="Subscribe to RSS feed for this search">' +
                          '<svg class="rss-icon" viewBox="0 0 24 24">' +
                          '<path d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248S0 22.546 0 20.752s1.456-3.248 3.252-3.248 3.251 1.454 3.251 3.248zM1.677 6.155v4.301c7.017 0 12.696 5.679 12.696 12.696h4.301c0-9.404-7.593-17-17-17zM1.677.003v4.301C12.083 4.304 20.321 12.54 20.321 23h4.301C24.622 11.228 13.395.003 1.677.003z"/>' +
                          '</svg>RSS</a></div>';
                
                data.results.forEach(result => {
                    // If this is a feed search with posts toggled, show posts instead of feeds
                    if (result.is_feed_search && showPosts && result.latest_post_title) {
                        // Display as a post result
                        const postDateStr = result.latest_post_date ? ` • ${result.latest_post_date}` : '';
                        html += `<div class="result-item page-result">
                            <div class="result-url">${result.basedomain}${postDateStr}</div>
                            <div class="result-title">
                                <a href="${result.latest_post_url}" target="_blank">${result.latest_post_title}</a>
                            </div>
                            <div class="result-snippet">${result.latest_post_snippet || ''}</div>
                            <div class="result-meta"></div>
                            <div class="result-actions">
                                <a class="action-link" onclick="searchMoreLike('${result.latest_post_url}')">Similar posts</a>
                                <a class="action-link" onclick="searchSimilarBlogs('${result.original_domain}')">Similar blogs</a>
                                <a class="action-link" onclick="searchFromSite('${result.original_domain}')">More from site</a>
                            </div>
                        </div>`;
                    } else if (result.is_feed_search && showPosts && !result.latest_post_title) {
                        // Skip feeds that don't have latest posts when in posts mode
                        return;
                    } else {
                        // Normal display (feeds or regular posts)
                        const siteClass = result.is_feed_search ? 'site-result' : 'page-result';
                        const dateStr = (!result.is_feed_search && result.date) ? ` • ${result.date}` : '';
                        html += `<div class="result-item ${siteClass}">
                            <div class="result-url">${result.basedomain}${dateStr}</div>
                            <div class="result-title"><a href="${result.url}" target="_blank">${result.title}</a></div>
                            <div class="result-snippet">${result.subtitle}</div>
                            <div class="result-meta"></div>
                            <div class="result-actions">`;
                        
                        if (!result.is_feed_search) {
                            html += `<a class="action-link" onclick="searchMoreLike('${result.url}')">Similar posts</a>`;
                            html += `<a class="action-link" onclick="searchSimilarBlogs('${result.original_domain}')">Similar blogs</a>`;
                        } else {
                            html += `<a class="action-link" onclick="searchSimilarBlogs('${result.original_domain}')">Similar blogs</a>`;
                        }
                        html += `<a class="action-link" onclick="searchFromSite('${result.original_domain}')">More from site</a>`;
                        
                        if (result.is_feed_search && result.rss_url) {
                            html += `<a href="${result.rss_url}" class="rss-link" target="_blank">📡 RSS Feed</a>`;
                        }
                        html += `</div></div>`;
                    }
                });
                
                resultsDiv.innerHTML = html;
            } else {
                const query = searchInput?.value || initialSearch?.value || '';
                resultsDiv.innerHTML = `<div class="no-results">
                    <p>No results found for "<strong>${query}</strong>"</p>
                    <p>Try different keywords or check your spelling.</p>
                </div>`;
            }
        }

        function updateURL(params) {
            const newURL = window.location.pathname + '?' + params.toString();
            history.pushState(null, '', newURL);
        }

        function cleanURL(url) {
            // Remove http:// and https:// schemes
            url = url.replace(/^https?:\/\//, '');
            // Remove www. prefix
            url = url.replace(/^www\./, '');
            // Remove trailing slash
            url = url.replace(/\/$/, '');
            return url;
        }

        function updateFilterVisibility(skipTimeDefault = false) {
            const exportGroup = document.getElementById('export-buttons-group');
            const togglePostsGroup = document.getElementById('toggle-posts-group');
            const contentGroup = document.getElementById('content-filter-group');
            const timeGroup = document.getElementById('time-filter-group');
            const sortGroup = document.getElementById('sort-filter-group');
            const timeFilter = document.getElementById('time-filter');
            
            // Update custom RSS builder visibility
            updateCustomRSSVisibility();
            
            if (currentSearchType === 'custom') {
                // Custom RSS: hide all filters and search controls
                if (togglePostsGroup) togglePostsGroup.style.display = 'none';
                if (exportGroup) exportGroup.style.display = 'none';
                if (contentGroup) contentGroup.style.display = 'none';
                if (timeGroup) timeGroup.style.display = 'none';
                if (sortGroup) sortGroup.style.display = 'none';
            } else if (currentSearchType === 'sites') {
                // RSS Feeds: show toggle posts and export buttons, hide content, time and sort filters
                if (togglePostsGroup) togglePostsGroup.style.display = 'flex';
                if (exportGroup) exportGroup.style.display = 'flex';
                if (contentGroup) contentGroup.style.display = 'none';
                if (timeGroup) timeGroup.style.display = 'none';
                if (sortGroup) sortGroup.style.display = 'none';
            } else {
                // Posts: hide toggle posts and export buttons, show content, time and sort filters
                if (togglePostsGroup) togglePostsGroup.style.display = 'none';
                if (exportGroup) exportGroup.style.display = 'none';
                if (contentGroup) contentGroup.style.display = 'flex';
                if (timeGroup) timeGroup.style.display = 'flex';
                if (sortGroup) sortGroup.style.display = 'flex';
                
                // Keep time filter as is - don't force a default value
            }
        }

        function togglePosts() {
            showPosts = !showPosts;
            const toggleBtn = document.getElementById('toggle-posts-btn');
            
            if (showPosts) {
                toggleBtn.textContent = '📄 Show Feeds';
                toggleBtn.style.backgroundColor = '#1a73e8';
                toggleBtn.style.color = 'white';
            } else {
                toggleBtn.textContent = '📄 Show Latest Posts';
                toggleBtn.style.backgroundColor = '#f1f3f4';
                toggleBtn.style.color = '#5f6368';
            }
            
            // Re-run search with new toggle state
            const query = searchInput?.value?.trim();
            if (query) {
                performSearch();
            }
        }

        function toggleSort() {
            const checkbox = document.getElementById('sort-time-checkbox');
            sortByTime = checkbox.checked;
            
            // Re-run search with new sort order
            const query = searchInput?.value?.trim();
            if (query) {
                performSearch();
            }
        }

        function exportOPML() {
            const query = (searchInput?.value || initialSearch?.value || '').trim();
            if (!query) {
                alert('Please perform a feed search first');
                return;
            }

            const params = new URLSearchParams({
                qry: query,
                type: currentSearchType,
                content: document.getElementById('content-filter')?.value || '',
                time: document.getElementById('time-filter')?.value || ''
            });
            
            // Create a temporary link to trigger download
            const link = document.createElement('a');
            link.href = '/api/export/opml?' + params.toString();
            link.download = 'feeds.opml';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportCSV() {
            const query = (searchInput?.value || initialSearch?.value || '').trim();
            if (!query) {
                alert('Please perform a feed search first');
                return;
            }

            const params = new URLSearchParams({
                qry: query,
                type: currentSearchType,
                content: document.getElementById('content-filter')?.value || '',
                time: document.getElementById('time-filter')?.value || ''
            });
            
            // Create a temporary link to trigger download
            const link = document.createElement('a');
            link.href = '/api/export/csv?' + params.toString();
            link.download = 'feeds.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function searchMoreLike(url) {
            const newQuery = 'like:' + url;
            if (searchInput) searchInput.value = newQuery;
            if (initialSearch) initialSearch.value = newQuery;
            
            // This function is now only for similar posts, so always switch to pages
            currentSearchType = 'pages';
            document.querySelectorAll('.type-tab, .type-tab-large').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === 'pages');
            });
            
            // Update filter visibility
            updateFilterVisibility();
            
            if (initialState && initialState.style.display !== 'none') {
                switchToSearchState(newQuery);
            }
            
            performSearch();
        }

        function searchSimilarBlogs(domain) {
            // Clean the domain to remove https:// etc for blog similarity
            const cleanDomain = cleanURL(domain);
            const newQuery = 'like:' + cleanDomain;
            if (searchInput) searchInput.value = newQuery;
            if (initialSearch) initialSearch.value = newQuery;
            
            // Switch to sites/feeds to show similar blogs
            currentSearchType = 'sites';
            document.querySelectorAll('.type-tab, .type-tab-large').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === 'sites');
            });
            
            // Update filter visibility
            updateFilterVisibility();
            
            if (initialState && initialState.style.display !== 'none') {
                switchToSearchState(newQuery);
            }
            
            performSearch();
        }


        function searchFromSite(domain) {
            // Use the original domain exactly as stored in database for accurate site: matching
            const newQuery = 'site:' + domain;
            if (searchInput) searchInput.value = newQuery;
            if (initialSearch) initialSearch.value = newQuery;
            
            // Always switch to posts/content to show posts from this site
            currentSearchType = 'pages';
            document.querySelectorAll('.type-tab, .type-tab-large').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === 'pages');
            });
            
            // Reset time filter to "Any time" and content filter to "All" first
            const timeFilter = document.getElementById('time-filter');
            const contentFilter = document.getElementById('content-filter');
            if (timeFilter) timeFilter.value = '';
            if (contentFilter) contentFilter.value = '';
            
            // Update filter visibility to show posts toolbar, skipping the time default
            updateFilterVisibility(true);
            
            if (initialState && initialState.style.display !== 'none') {
                switchToSearchState(newQuery);
            }
            
            performSearch();
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            const urlParams = new URLSearchParams(window.location.search);
            const query = urlParams.get('qry') || '';
            const type = urlParams.get('type') || 'pages';
            const content = urlParams.get('content') || '';
            const time = urlParams.get('time') || '';
            const sort = urlParams.get('sort');
            
            // Update current search type
            currentSearchType = type;
            
            // Update sort state
            sortByTime = (sort === 'time');
            const sortCheckbox = document.getElementById('sort-time-checkbox');
            if (sortCheckbox) {
                sortCheckbox.checked = sortByTime;
            }
            
            // Update UI state based on URL parameters
            if (query) {
                // Switch to search state if we have a query
                if (initialState && initialState.style.display !== 'none') {
                    switchToSearchState(query);
                }
                
                // Update search input
                if (searchInput) searchInput.value = query;
                
                // Update type tabs
                document.querySelectorAll('.type-tab, .type-tab-large').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.type === type);
                });
                
                // Update filter dropdowns
                const contentFilter = document.getElementById('content-filter');
                const timeFilter = document.getElementById('time-filter');
                if (contentFilter) contentFilter.value = content;
                if (timeFilter) timeFilter.value = time;
                
                // Update filter visibility
                updateFilterVisibility();
                
                // Perform search with current parameters
                performSearch();
            } else {
                // No query, show initial state
                if (initialState) initialState.style.display = 'block';
                if (searchState) searchState.style.display = 'none';
                if (initialSearch) initialSearch.value = '';
                
                // Update type tabs for initial state
                document.querySelectorAll('.type-tab-large').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.type === type);
                });
            }
        });

        // Clear all settings on page refresh (but stay in search view)
        function clearAllSettingsOnRefresh() {
            // Clear URL parameters
            const url = new URL(window.location);
            url.search = '';
            window.history.replaceState({}, '', url);
            
            // Clear search inputs
            if (searchInput) searchInput.value = '';
            if (initialSearch) initialSearch.value = '';
            
            // Reset filters to defaults
            const timeFilter = document.getElementById('time-filter');
            const contentFilter = document.getElementById('content-filter');
            if (timeFilter) {
                timeFilter.value = '';
                timeFilter.selectedIndex = 0; // Explicitly select first option
            }
            if (contentFilter) {
                contentFilter.value = '';
                contentFilter.selectedIndex = 0; // Explicitly select first option ("All")
            }
            
            // Reset search type to posts
            currentSearchType = 'pages';
            document.querySelectorAll('.type-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === 'pages');
            });
            document.querySelectorAll('.type-tab-large').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.type === 'pages');
            });
            
            // Clear results
            if (resultsDiv) resultsDiv.innerHTML = '';
            
            // Stay in search view (don't go back to landing page)
            if (initialState && searchState) {
                initialState.style.display = 'none';
                searchState.style.display = 'block';
            }
        }
        
        // Initialize page based on URL parameters
        function initializePage() {
            const urlParams = new URLSearchParams(window.location.search);
            const query = urlParams.get('qry') || '{{.Query}}';
            const type = urlParams.get('type') || '{{.SearchType}}' || 'pages';
            const content = urlParams.get('content') || '{{.SearchContent}}';
            const time = urlParams.get('time') || '{{.SearchTime}}';
            const sort = urlParams.get('sort');
            
            // Update current search type
            currentSearchType = type;
            
            // Update sort state
            sortByTime = (sort === 'time');
            const sortCheckbox = document.getElementById('sort-time-checkbox');
            if (sortCheckbox) {
                sortCheckbox.checked = sortByTime;
            }
            
            if (query) {
                // We have a query, set up search state
                if (initialState) initialState.style.display = 'none';
                if (searchState) searchState.style.display = 'block';
                if (searchInput) searchInput.value = query;
                
                // Update type tabs
                document.querySelectorAll('.type-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.type === type);
                });
                
                // Update filter dropdowns
                const contentFilter = document.getElementById('content-filter');
                const timeFilter = document.getElementById('time-filter');
                if (contentFilter) contentFilter.value = content;
                if (timeFilter) timeFilter.value = time;
                
                // Update filter visibility
                updateFilterVisibility();
                
                // Perform search automatically
                performSearch();
            } else {
                // No query, show initial state
                if (initialState) initialState.style.display = 'block';
                if (searchState) searchState.style.display = 'none';
                
                // Update type tabs for initial state
                document.querySelectorAll('.type-tab-large').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.type === type);
                });
                
                // Check if this is a page refresh (not a navigation) and clear settings
                if (performance.navigation.type === performance.navigation.TYPE_RELOAD || 
                    performance.getEntriesByType("navigation")[0].type === "reload") {
                    clearAllSettingsOnRefresh();
                }
            }
            
            // Initialize filter visibility
            updateFilterVisibility();
            updateCustomRSSVisibility();
        }
        
        function openRSSFeed() {
            const query = (searchInput?.value || initialSearch?.value || '').trim();
            if (!query) {
                alert('Please perform a search first');
                return false;
            }

            const params = new URLSearchParams({
                qry: query,
                type: currentSearchType,
                content: document.getElementById('content-filter')?.value || '',
                time: document.getElementById('time-filter')?.value || ''
            });
            
            // Add include_posts parameter for RSS feeds when toggle is enabled
            if (currentSearchType === 'sites' && showPosts) {
                params.set('include_posts', 'true');
            }
            
            // Add sort parameter for posts
            if (currentSearchType === 'pages' && sortByTime) {
                params.set('sort', 'time');
            }
            
            const rssURL = '/rss?' + params.toString();
            window.open(rssURL, '_blank');
            return false;
        }
        
        // Custom RSS Builder Functions
        
        // Node type configurations
        const nodeTypes = {
            'search-source': {
                icon: '🔍',
                title: 'Search Source',
                inputs: ['Query', 'Type'],
                hasOutput: true,
                color: '#2196F3'
            },
            'text-filter': {
                icon: '🔤',
                title: 'Text Filter',
                inputs: ['Pattern', 'Type', 'Field', 'Mode'],
                hasInput: true,
                hasOutput: true,
                color: '#FF9800'
            },
            'sort': {
                icon: '⬇️',
                title: 'Sort',
                inputs: ['Field'],
                hasInput: true,
                hasOutput: true,
                color: '#795548'
            },
            'limit': {
                icon: '#️⃣',
                title: 'Limit',
                inputs: ['Count'],
                hasInput: true,
                hasOutput: true,
                color: '#607D8B'
            },
            'output': {
                icon: '📄',
                title: 'RSS Output',
                inputs: ['Title', 'Description'],
                hasInput: true,
                hasOutput: false,
                color: '#F44336'
            }
        };

        // Initialize drag and drop for palette items
        function initializePalette() {
            const paletteItems = document.querySelectorAll('.palette-item');
            paletteItems.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', this.dataset.nodeType);
                });
            });

            canvas.addEventListener('dragover', function(e) {
                e.preventDefault();
            });

            canvas.addEventListener('drop', function(e) {
                e.preventDefault();
                const nodeType = e.dataTransfer.getData('text/plain');
                const rect = canvas.getBoundingClientRect();
                // Account for zoom and pan offset when calculating position
                const x = ((e.clientX - rect.left) - canvasOffset.x) / canvasScale;
                const y = ((e.clientY - rect.top) - canvasOffset.y) / canvasScale;
                createNode(nodeType, x, y);
            });
            
            // Cancel connections when clicking on empty canvas
            canvas.addEventListener('click', function(e) {
                // Only cancel if clicking on the canvas itself (not on nodes or connection points)
                if (e.target === canvas && isConnecting) {
                    isConnecting = false;
                    clearConnectionVisuals();
                    connectionStart = null;
                    clearConnectionStatus();
                }
            });
            
            // Add panning functionality to canvas container
            const canvasContainer = document.querySelector('.builder-canvas-container');
            
            canvasContainer.addEventListener('mousedown', function(e) {
                // Only start panning if clicking on the container itself or canvas background
                if (e.target === canvasContainer || e.target === canvas) {
                    isPanning = true;
                    panStart.x = e.clientX - canvasOffset.x;
                    panStart.y = e.clientY - canvasOffset.y;
                    canvasContainer.classList.add('panning');
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (isPanning) {
                    canvasOffset.x = e.clientX - panStart.x;
                    canvasOffset.y = e.clientY - panStart.y;
                    updateCanvasTransform();
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mouseup', function(e) {
                if (isPanning) {
                    isPanning = false;
                    canvasContainer.classList.remove('panning');
                }
            });
        }

        // Create a new node
        function createNode(nodeType, x, y) {
            const nodeId = 'node-' + nodeIdCounter++;
            const config = nodeTypes[nodeType];
            
            const node = document.createElement('div');
            node.className = 'canvas-node';
            node.id = nodeId;
            node.style.left = x + 'px';
            node.style.top = y + 'px';
            node.style.borderColor = config.color;
            node.draggable = false; // Disable HTML5 drag and drop to prevent conflicts

            let inputsHTML = '';
            if (config.inputs) {
                config.inputs.forEach(input => {
                    if (input === 'Type' || input === 'Mode' || input === 'Field') {
                        let options = '';
                        if (input === 'Type') {
                            if (nodeType === 'text-filter') {
                                options = '<option value="keyword">Keyword</option><option value="regex">Regular Expression</option>';
                            } else {
                                options = '<option value="pages">Posts</option><option value="sites">RSS Feeds</option>';
                            }
                        } else if (input === 'Mode') {
                            options = '<option value="include">Include</option><option value="exclude">Exclude</option>';
                        } else if (input === 'Field') {
                            if (nodeType === 'text-filter') {
                                options = '<option value="title">Title</option><option value="description">Description</option><option value="content">Content</option>';
                            } else {
                                options = '<option value="timestamp">Timestamp</option><option value="relevance">Relevance</option>';
                            }
                        }
                        inputsHTML += `<div>${input}: <select class="node-select" data-field="${input.toLowerCase()}">${options}</select></div>`;
                    } else {
                        inputsHTML += `<div>${input}: <input type="text" class="node-input" data-field="${input.toLowerCase()}" placeholder="${input}"></div>`;
                    }
                });
            }

            node.innerHTML = `
                <div class="node-header">
                    <div class="node-title">
                        <span>${config.icon}</span>
                        <span>${config.title}</span>
                    </div>
                    <button class="node-delete" onclick="deleteNode('${nodeId}')">×</button>
                </div>
                <div class="node-content">
                    ${inputsHTML}
                </div>
                ${config.hasInput ? '<div class="connection-point connection-input"></div>' : ''}
                ${config.hasOutput ? '<div class="connection-point connection-output"></div>' : ''}
            `;

            canvas.appendChild(node);
            
            const nodeData = {
                id: nodeId,
                type: nodeType,
                x: x,
                y: y,
                config: config,
                inputs: {},
                connections: { inputs: [], outputs: [] }
            };
            
            rssNodes.set(nodeId, nodeData);

            // Add event listeners
            makeDraggable(node);
            addInputListeners(node, nodeData);
            addConnectionListeners(node, nodeData);

            // Auto-refresh preview when nodes change
            setTimeout(refreshPreview, 100);

            return nodeData;
        }

        // Make nodes draggable
        function makeDraggable(node) {
            let isDragging = false;
            let startX, startY, nodeX, nodeY;

            node.addEventListener('mousedown', function(e) {
                if (e.target.classList.contains('node-delete') || 
                    e.target.classList.contains('node-input') || 
                    e.target.classList.contains('node-select') ||
                    e.target.classList.contains('connection-point')) {
                    return;
                }

                // Prevent default drag behavior and event bubbling
                e.preventDefault();
                e.stopPropagation();

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                nodeX = parseInt(node.style.left) || 0;
                nodeY = parseInt(node.style.top) || 0;

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                
                // Select node
                document.querySelectorAll('.canvas-node').forEach(n => n.classList.remove('selected'));
                node.classList.add('selected');
                selectedNode = node.id;
            });

            function onMouseMove(e) {
                if (!isDragging) return;
                
                e.preventDefault();
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newX = nodeX + deltaX;
                const newY = nodeY + deltaY;
                
                // Allow nodes to be positioned anywhere on the expanded canvas
                node.style.left = newX + 'px';
                node.style.top = newY + 'px';

                // Update node data
                const nodeData = rssNodes.get(node.id);
                if (nodeData) {
                    nodeData.x = newX;
                    nodeData.y = newY;
                }

                // Use lightweight position updates during dragging for smooth performance
                if (!node._updateTimeout) {
                    node._updateTimeout = setTimeout(() => {
                        updateConnectionPositions(); // Use lightweight updates during drag
                        node._updateTimeout = null;
                    }, 16); // ~60fps
                }
            }

            function onMouseUp(e) {
                if (isDragging) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Clear any pending updates and do a final update
                    if (node._updateTimeout) {
                        clearTimeout(node._updateTimeout);
                        node._updateTimeout = null;
                    }
                    updateConnections();
                }
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
        }

        // Add input event listeners
        function addInputListeners(node, nodeData) {
            const inputs = node.querySelectorAll('.node-input, .node-select');
            inputs.forEach(input => {
                input.addEventListener('input', function() {
                    const field = this.dataset.field;
                    nodeData.inputs[field] = this.value;
                    refreshPreview();
                });
            });
        }

        // Helper functions for connection visual feedback
        function showConnectionStatus(message, type = 'info') {
            // Remove existing status message
            clearConnectionStatus();
            
            const statusDiv = document.createElement('div');
            statusDiv.id = 'connection-status';
            statusDiv.style.position = 'absolute';
            statusDiv.style.top = '10px';
            statusDiv.style.left = '50%';
            statusDiv.style.transform = 'translateX(-50%)';
            statusDiv.style.padding = '8px 16px';
            statusDiv.style.borderRadius = '4px';
            statusDiv.style.fontSize = '14px';
            statusDiv.style.fontWeight = 'bold';
            statusDiv.style.zIndex = '1000';
            statusDiv.style.pointerEvents = 'none';
            statusDiv.textContent = message;
            
            if (type === 'success') {
                statusDiv.style.backgroundColor = '#4CAF50';
                statusDiv.style.color = 'white';
            } else if (type === 'error') {
                statusDiv.style.backgroundColor = '#f44336';
                statusDiv.style.color = 'white';
            } else {
                statusDiv.style.backgroundColor = '#2196F3';
                statusDiv.style.color = 'white';
            }
            
            canvas.appendChild(statusDiv);
        }
        
        function clearConnectionStatus() {
            const existingStatus = document.getElementById('connection-status');
            if (existingStatus) {
                existingStatus.remove();
            }
        }
        
        function clearConnectionVisuals() {
            // Reset all connection points to default style
            document.querySelectorAll('.connection-point').forEach(point => {
                point.style.backgroundColor = '#1a73e8';
                point.style.transform = point.classList.contains('connection-input') ? 
                    'translateY(-50%)' : 
                    'translateY(-50%)';
            });
        }

        // Add connection event listeners
        function addConnectionListeners(node, nodeData) {
            const connectionPoints = node.querySelectorAll('.connection-point');
            connectionPoints.forEach(point => {
                point.addEventListener('click', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    startConnection(nodeData.id, point.classList.contains('connection-output'));
                });
                
                // Add visual feedback on hover
                point.addEventListener('mouseenter', function(e) {
                    if (connectionStart) {
                        // Check if this is a valid connection target
                        const isOutput = point.classList.contains('connection-output');
                        const isInput = point.classList.contains('connection-input');
                        
                        if ((connectionStart.isOutput && isInput) || (!connectionStart.isOutput && isOutput)) {
                            if (connectionStart.nodeId !== nodeData.id) {
                                point.style.backgroundColor = '#4CAF50';
                                point.style.transform = point.classList.contains('connection-input') ? 
                                    'translateY(-50%) scale(1.3)' : 
                                    'translateY(-50%) scale(1.3)';
                            } else {
                                point.style.backgroundColor = '#f44336';
                            }
                        } else {
                            point.style.backgroundColor = '#f44336';
                        }
                    } else {
                        point.style.backgroundColor = '#2196F3';
                        point.style.transform = point.classList.contains('connection-input') ? 
                            'translateY(-50%) scale(1.2)' : 
                            'translateY(-50%) scale(1.2)';
                    }
                });
                
                point.addEventListener('mouseleave', function(e) {
                    point.style.backgroundColor = '#1a73e8';
                    point.style.transform = point.classList.contains('connection-input') ? 
                        'translateY(-50%)' : 
                        'translateY(-50%)';
                });
            });
        }

        // Start creating a connection
        function startConnection(nodeId, isOutput) {
            if (isConnecting) {
                // Complete connection
                completeConnection(nodeId, !isOutput);
            } else {
                // Start connection
                isConnecting = true;
                connectionStart = { nodeId: nodeId, isOutput: isOutput };
                
                // Add visual indicator to starting node
                const startingNode = document.getElementById(nodeId);
                const startingPoint = startingNode.querySelector(isOutput ? '.connection-output' : '.connection-input');
                if (startingPoint) {
                    startingPoint.style.backgroundColor = '#FF9800';
                    startingPoint.style.transform = startingPoint.classList.contains('connection-input') ? 
                        'translateY(-50%) scale(1.4)' : 
                        'translateY(-50%) scale(1.4)';
                }
                
                // Add a status message to the canvas
                showConnectionStatus('Click on another node\'s connection point to connect');
            }
        }

        // Complete a connection
        function completeConnection(targetNodeId, isTargetInput) {
            if (!connectionStart || 
                connectionStart.nodeId === targetNodeId ||
                connectionStart.isOutput === !isTargetInput) {
                // Invalid connection
                isConnecting = false;
                clearConnectionVisuals();
                connectionStart = null;
                showConnectionStatus('Invalid connection', 'error');
                setTimeout(() => clearConnectionStatus(), 2000);
                return;
            }

            // Check if connection already exists
            const from = connectionStart.isOutput ? connectionStart.nodeId : targetNodeId;
            const to = connectionStart.isOutput ? targetNodeId : connectionStart.nodeId;
            
            const existingConnection = rssConnections.find(conn => 
                conn.from === from && conn.to === to
            );
            
            if (existingConnection) {
                isConnecting = false;
                clearConnectionVisuals();
                connectionStart = null;
                showConnectionStatus('Connection already exists', 'error');
                setTimeout(() => clearConnectionStatus(), 2000);
                return;
            }

            const connection = {
                from: from,
                to: to,
                id: 'conn-' + Date.now()
            };

            rssConnections.push(connection);

            // Update node data
            const fromNode = rssNodes.get(connection.from);
            const toNode = rssNodes.get(connection.to);
            if (fromNode) fromNode.connections.outputs.push(connection.id);
            if (toNode) toNode.connections.inputs.push(connection.id);

            isConnecting = false;
            clearConnectionVisuals();
            connectionStart = null;
            updateConnections();
            refreshPreview();
            showConnectionStatus('Connection created successfully!', 'success');
            setTimeout(() => clearConnectionStatus(), 2000);
        }

        // Update connection positions only (lightweight, for during-drag updates)
        function updateConnectionPositions() {
            const canvas = document.getElementById('rss-canvas');
            if (!canvas) return;

            rssConnections.forEach(connection => {
                const line = canvas.querySelector(`svg[data-connection-id="${connection.id}"]`);
                if (!line) return; // Connection SVG doesn't exist yet, skip

                const fromNode = document.getElementById(connection.from);
                const toNode = document.getElementById(connection.to);
                
                if (!fromNode || !toNode) return;

                // Use node positions directly
                const fromNodeX = parseInt(fromNode.style.left) || 0;
                const fromNodeY = parseInt(fromNode.style.top) || 0;
                const toNodeX = parseInt(toNode.style.left) || 0;
                const toNodeY = parseInt(toNode.style.top) || 0;
                
                const nodeWidth = 150;
                const nodeHeight = 80;
                
                const startX = fromNodeX + nodeWidth;
                const startY = fromNodeY + nodeHeight / 2;
                const endX = toNodeX;
                const endY = toNodeY + nodeHeight / 2;

                const minX = Math.min(startX, endX);
                const minY = Math.min(startY, endY);
                const width = Math.abs(endX - startX) + 40;
                const height = Math.abs(endY - startY) + 40;

                // Update SVG position and dimensions
                line.style.left = (minX - 20) + 'px';
                line.style.top = (minY - 20) + 'px';
                line.style.width = width + 'px';
                line.style.height = height + 'px';
                line.setAttribute('viewBox', `0 0 ${width} ${height}`);
                
                // Update path
                const path = line.querySelector('path:not([d*="M0,0"])'); // Find the main path, not the arrowhead
                if (path) {
                    const controlX1 = (startX - minX + 20) + (endX - startX) * 0.3;
                    const controlX2 = (startX - minX + 20) + (endX - startX) * 0.7;
                    
                    const pathData = `M ${startX - minX + 20} ${startY - minY + 20} C ${controlX1} ${startY - minY + 20} ${controlX2} ${endY - minY + 20} ${endX - minX + 20} ${endY - minY + 20}`;
                    path.setAttribute('d', pathData);
                }
            });
        }

        // Update connection lines (full rebuild, for complete updates)
        function updateConnections() {
            // Remove old connection lines more thoroughly
            const canvas = document.getElementById('rss-canvas');
            if (canvas) {
                // Remove all SVG connection elements
                canvas.querySelectorAll('.connection-line').forEach(line => line.remove());
                // Also remove any orphaned SVG elements that might be left behind
                canvas.querySelectorAll('svg[data-connection-id]').forEach(svg => svg.remove());
            }

            rssConnections.forEach(connection => {
                const fromNode = document.getElementById(connection.from);
                const toNode = document.getElementById(connection.to);
                
                if (!fromNode || !toNode) return;

                const fromPoint = fromNode.querySelector('.connection-output');
                const toPoint = toNode.querySelector('.connection-input');
                
                if (!fromPoint || !toPoint) return;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                line.className = 'connection-line';
                line.setAttribute('data-connection-id', connection.id); // Add identifier for position updates
                line.style.position = 'absolute';
                line.style.pointerEvents = 'none';
                line.style.zIndex = '1';
                
                // Use node positions directly instead of getBoundingClientRect to avoid coordinate issues
                const fromNodeX = parseInt(fromNode.style.left) || 0;
                const fromNodeY = parseInt(fromNode.style.top) || 0;
                const toNodeX = parseInt(toNode.style.left) || 0;
                const toNodeY = parseInt(toNode.style.top) || 0;
                
                // Connection points are positioned at the center-right (output) and center-left (input) of nodes
                const nodeWidth = 150; // Approximate node width
                const nodeHeight = 80; // Approximate node height
                
                const startX = fromNodeX + nodeWidth; // Right edge for output
                const startY = fromNodeY + nodeHeight / 2; // Vertical center
                const endX = toNodeX; // Left edge for input  
                const endY = toNodeY + nodeHeight / 2; // Vertical center

                const minX = Math.min(startX, endX);
                const minY = Math.min(startY, endY);
                const width = Math.abs(endX - startX) + 40;
                const height = Math.abs(endY - startY) + 40;

                line.style.left = (minX - 20) + 'px';
                line.style.top = (minY - 20) + 'px';
                line.style.width = width + 'px';
                line.style.height = height + 'px';
                line.setAttribute('viewBox', `0 0 ${width} ${height}`);

                // Create arrow marker definition
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrowhead-${connection.id}`);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '7');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3.5');
                marker.setAttribute('orient', 'auto');
                marker.setAttribute('markerUnits', 'strokeWidth');
                
                const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                arrowPath.setAttribute('d', 'M0,0 L0,7 L9,3.5 z');
                arrowPath.setAttribute('fill', '#1a73e8');
                
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
                line.appendChild(defs);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const controlX1 = (startX - minX + 20) + (endX - startX) * 0.3;
                const controlX2 = (startX - minX + 20) + (endX - startX) * 0.7;
                
                path.setAttribute('d', `M ${startX - minX + 20} ${startY - minY + 20} C ${controlX1} ${startY - minY + 20} ${controlX2} ${endY - minY + 20} ${endX - minX + 20} ${endY - minY + 20}`);
                path.setAttribute('stroke', '#1a73e8');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.setAttribute('marker-end', `url(#arrowhead-${connection.id})`);
                
                line.appendChild(path);
                canvas.appendChild(line);
            });
        }

        // Delete a node
        function deleteNode(nodeId) {
            const node = document.getElementById(nodeId);
            if (node) {
                node.remove();
            }
            
            // Remove from data
            rssNodes.delete(nodeId);
            
            // Remove connections
            rssConnections = rssConnections.filter(conn => 
                conn.from !== nodeId && conn.to !== nodeId
            );
            
            // Update other nodes' connection data
            rssNodes.forEach(nodeData => {
                nodeData.connections.inputs = nodeData.connections.inputs.filter(connId => 
                    !connId.includes(nodeId)
                );
                nodeData.connections.outputs = nodeData.connections.outputs.filter(connId => 
                    !connId.includes(nodeId)
                );
            });

            updateConnections();
            refreshPreview();
        }

        // Refresh preview
        function refreshPreview() {
            const preview = document.getElementById('rss-preview');
            if (!preview) return;

            // Build the workflow
            const workflow = buildWorkflow();
            if (!workflow) {
                preview.innerHTML = '<div class="preview-placeholder">Build your flowchart to see RSS preview</div>';
                return;
            }

            // Show loading state
            preview.innerHTML = '<div class="preview-placeholder">Generating preview...</div>';
            
            // Process workflow with real data
            processWorkflow(workflow).then(items => {
                displayRSSPreview(items);
            }).catch(error => {
                console.error('Error processing workflow:', error);
                preview.innerHTML = '<div class="preview-placeholder">Error generating preview. Check your configuration.</div>';
            });
        }

        // Process workflow with real API calls
        async function processWorkflow(workflow) {
            let allItems = [];
            
            // Process each source
            for (const source of workflow.sources) {
                try {
                    let items = [];
                    
                    if (source.type === 'search-source') {
                        // Get search parameters from the node
                        const query = source.inputs.query || '';
                        const type = source.inputs.type || 'pages';
                        
                        if (!query.trim()) {
                            console.warn('Search source has no query configured');
                            continue;
                        }
                        
                        // Make API call to the search endpoint
                        const params = new URLSearchParams();
                        params.set('qry', query);
                        if (type === 'sites') params.set('type', 'feeds');
                        
                        const response = await fetch(`/api/search?${params.toString()}`);
                        const data = await response.json();
                        
                        // Convert search results to RSS item format
                        items = data.results ? data.results.slice(0, 10).map(result => ({
                            title: result.title,
                            description: result.description || result.title,
                            link: result.url,
                            pubDate: result.date || new Date().toISOString(),
                            source: `Search: ${query}`
                        })) : [];
                        
                    } else if (source.type === 'search-source') {
                        // For RSS sources, we'd need to fetch and parse the RSS feed
                        // For now, we'll skip this or show a placeholder
                        console.warn('RSS source processing not implemented yet');
                        continue;
                    }
                    
                    allItems = allItems.concat(items);
                } catch (error) {
                    console.error(`Error processing source ${source.type}:`, error);
                }
            }
            
            // Apply filters and processors
            let processedItems = allItems;
            
            // Apply content filters
            for (const filter of workflow.filters) {
                if (filter.type === 'text-filter') {
                    const pattern = filter.inputs.pattern || '';
                    const mode = filter.inputs.mode || 'include';
                    const field = filter.inputs.field || 'title';
                    
                    if (pattern.trim()) {
                        const regex = new RegExp(pattern, 'i');
                        processedItems = processedItems.filter(item => {
                            const text = item[field] || '';
                            const matches = regex.test(text);
                            return mode === 'include' ? matches : !matches;
                        });
                    }
                }
            }
            
            // Apply processors (sort, limit, etc.)
            for (const processor of workflow.processors) {
                if (processor.type === 'sort') {
                    const field = processor.inputs.field || 'pubDate';
                    const order = processor.inputs.order || 'desc';
                    
                    processedItems.sort((a, b) => {
                        const aVal = new Date(a[field]);
                        const bVal = new Date(b[field]);
                        return order === 'desc' ? bVal - aVal : aVal - bVal;
                    });
                } else if (processor.type === 'limit') {
                    const count = parseInt(processor.inputs.count) || 10;
                    processedItems = processedItems.slice(0, count);
                }
            }
            
            return processedItems;
        }

        // Build workflow from nodes
        function buildWorkflow() {
            const sources = [];
            const filters = [];
            const processors = [];
            let output = null;

            rssNodes.forEach(nodeData => {
                if (nodeData.type === 'search-source') {
                    sources.push(nodeData);
                } else if (nodeData.type === 'text-filter') {
                    filters.push(nodeData);
                } else if (nodeData.type === 'sort' || nodeData.type === 'limit') {
                    processors.push(nodeData);
                } else if (nodeData.type === 'output') {
                    output = nodeData;
                }
            });

            if (sources.length === 0 || !output) {
                return null;
            }

            return { sources, filters, processors, output };
        }

        // Generate mock RSS items for preview
        function generateMockRSSItems(workflow) {
            const mockItems = [];
            const sampleTitles = [
                'Understanding Modern Web Development',
                'The Future of AI and Machine Learning',
                'Best Practices for Database Design',
                'Introduction to Cloud Computing',
                'Mobile App Development Trends'
            ];

            workflow.sources.forEach((source, index) => {
                for (let i = 0; i < 3; i++) {
                    mockItems.push({
                        title: sampleTitles[(index * 3 + i) % sampleTitles.length],
                        description: `Sample description for ${source.type} content. This would be the actual content from the RSS feed or search results.`,
                        link: `https://example.com/article-${index}-${i}`,
                        pubDate: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                        source: 'Search Results'
                    });
                }
            });

            // Apply filters (mock)
            let filteredItems = mockItems;
            workflow.filters.forEach(filter => {
                if (filter.type === 'keyword-filter' && filter.inputs.keywords) {
                    const mode = filter.inputs.mode || 'include';
                    const keywords = filter.inputs.keywords.toLowerCase().split(',').map(k => k.trim());
                    
                    if (mode === 'include') {
                        filteredItems = filteredItems.filter(item => 
                            keywords.some(keyword => 
                                item.title.toLowerCase().includes(keyword) || 
                                item.description.toLowerCase().includes(keyword)
                            )
                        );
                    } else {
                        filteredItems = filteredItems.filter(item => 
                            !keywords.some(keyword => 
                                item.title.toLowerCase().includes(keyword) || 
                                item.description.toLowerCase().includes(keyword)
                            )
                        );
                    }
                }
            });

            // Apply processors
            workflow.processors.forEach(processor => {
                if (processor.type === 'sort') {
                    const order = processor.inputs.order || 'desc';
                    filteredItems.sort((a, b) => {
                        const dateA = new Date(a.pubDate);
                        const dateB = new Date(b.pubDate);
                        return order === 'desc' ? dateB - dateA : dateA - dateB;
                    });
                } else if (processor.type === 'limit') {
                    const count = parseInt(processor.inputs.count) || 10;
                    filteredItems = filteredItems.slice(0, count);
                }
            });

            return filteredItems;
        }

        // Display RSS preview
        function displayRSSPreview(items) {
            const preview = document.getElementById('rss-preview');
            if (items.length === 0) {
                preview.innerHTML = '<div class="preview-placeholder">No items match your criteria</div>';
                return;
            }

            const itemsHTML = items.map(item => `
                <div class="rss-item">
                    <div class="rss-item-title">${item.title}</div>
                    <div class="rss-item-description">${item.description}</div>
                    <div class="rss-item-meta">
                        ${new Date(item.pubDate).toLocaleDateString()} • ${item.source}
                    </div>
                </div>
            `).join('');

            preview.innerHTML = itemsHTML;
        }

        // Save RSS configuration
        function saveRSSConfig() {
            const config = {
                nodes: Array.from(rssNodes.values()),
                connections: rssConnections
            };
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'rss-config.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Load RSS configuration
        function loadRSSConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const config = JSON.parse(e.target.result);
                        loadConfiguration(config);
                    } catch (error) {
                        alert('Invalid configuration file');
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Load configuration
        function loadConfiguration(config) {
            // Clear existing
            rssNodes.clear();
            rssConnections = [];
            canvas.innerHTML = '';

            // Load nodes
            config.nodes.forEach(nodeData => {
                const node = createNodeFromData(nodeData);
                // Set input values
                Object.keys(nodeData.inputs).forEach(key => {
                    const input = node.querySelector(`[data-field="${key}"]`);
                    if (input) {
                        input.value = nodeData.inputs[key];
                    }
                });
            });

            // Load connections
            rssConnections = config.connections || [];
            
            setTimeout(() => {
                updateConnections();
                refreshPreview();
            }, 100);
        }

        // Create node from saved data
        function createNodeFromData(nodeData) {
            const config = nodeTypes[nodeData.type];
            const node = document.createElement('div');
            node.className = 'canvas-node';
            node.id = nodeData.id;
            node.style.left = nodeData.x + 'px';
            node.style.top = nodeData.y + 'px';
            node.style.borderColor = config.color;
            node.draggable = false; // Disable HTML5 drag and drop to prevent conflicts

            let inputsHTML = '';
            if (config.inputs) {
                config.inputs.forEach(input => {
                    if (input === 'Type' || input === 'Mode' || input === 'Field') {
                        let options = '';
                        if (input === 'Type') {
                            if (nodeData.type === 'text-filter') {
                                options = '<option value="keyword">Keyword</option><option value="regex">Regular Expression</option>';
                            } else {
                                options = '<option value="pages">Posts</option><option value="sites">RSS Feeds</option>';
                            }
                        } else if (input === 'Mode') {
                            options = '<option value="include">Include</option><option value="exclude">Exclude</option>';
                        } else if (input === 'Field') {
                            if (nodeData.type === 'text-filter') {
                                options = '<option value="title">Title</option><option value="description">Description</option><option value="content">Content</option>';
                            } else {
                                options = '<option value="timestamp">Timestamp</option><option value="relevance">Relevance</option>';
                            }
                        }
                        inputsHTML += `<div>${input}: <select class="node-select" data-field="${input.toLowerCase()}">${options}</select></div>`;
                    } else {
                        inputsHTML += `<div>${input}: <input type="text" class="node-input" data-field="${input.toLowerCase()}" placeholder="${input}"></div>`;
                    }
                });
            }

            node.innerHTML = `
                <div class="node-header">
                    <div class="node-title">
                        <span>${config.icon}</span>
                        <span>${config.title}</span>
                    </div>
                    <button class="node-delete" onclick="deleteNode('${nodeData.id}')">×</button>
                </div>
                <div class="node-content">
                    ${inputsHTML}
                </div>
                ${config.hasInput ? '<div class="connection-point connection-input"></div>' : ''}
                ${config.hasOutput ? '<div class="connection-point connection-output"></div>' : ''}
            `;

            canvas.appendChild(node);
            rssNodes.set(nodeData.id, nodeData);

            makeDraggable(node);
            addInputListeners(node, nodeData);
            addConnectionListeners(node, nodeData);

            return node;
        }

        // Generate custom RSS feed
        function generateCustomRSS() {
            console.log('Generate RSS clicked');
            const workflow = buildWorkflow();
            if (!workflow) {
                alert('Please create a complete workflow with at least one source and an output node.');
                return;
            }

            console.log('Workflow built:', workflow);

            // Create the config data in the format expected by the backend
            const configData = {
                nodes: Array.from(rssNodes.values()),
                connections: rssConnections
            };
            
            console.log('Config data:', configData);
            
            try {
                // Strip out Unicode characters from the config data before encoding
                const configDataCleaned = JSON.parse(JSON.stringify(configData, (key, value) => {
                    if (typeof value === 'string') {
                        // Replace emoji and other Unicode with simple text
                        return value.replace(/🔍/g, 'Search').replace(/📄/g, 'Output').replace(/[^\x00-\x7F]/g, '');
                    }
                    return value;
                }));
                
                const configString = JSON.stringify(configDataCleaned);
                const encodedConfig = btoa(configString);
                const rssUrl = `/api/custom-rss?config=${encodedConfig}`;
                
                console.log('Generated RSS URL:', rssUrl);
                
                // Open the RSS feed in a new window instead of just showing an alert
                window.open(rssUrl, '_blank');
                
            } catch (error) {
                console.error('Error generating RSS URL:', error);
                alert('Error generating RSS feed: ' + error.message);
            }
        }

        // Copy RSS URL to clipboard
        function copyRSSUrl() {
            const workflow = buildWorkflow();
            if (!workflow) {
                alert('Please create a complete workflow first.');
                return;
            }

            const configData = {
                nodes: Array.from(rssNodes.values()),
                connections: rssConnections
            };
            
            // Strip out Unicode characters from the config data before encoding
            const configDataCleaned = JSON.parse(JSON.stringify(configData, (key, value) => {
                if (typeof value === 'string') {
                    // Replace emoji and other Unicode with simple text
                    return value.replace(/🔍/g, 'Search').replace(/📄/g, 'Output').replace(/[^\x00-\x7F]/g, '');
                }
                return value;
            }));
            
            const configString = JSON.stringify(configDataCleaned);
            const encodedConfig = btoa(configString);
            const rssUrl = `${window.location.origin}/api/custom-rss?config=${encodedConfig}`;
            
            navigator.clipboard.writeText(rssUrl).then(() => {
                alert('RSS URL copied to clipboard!');
            }).catch(() => {
                prompt('Copy this RSS URL:', rssUrl);
            });
        }

        // Show/hide custom RSS builder based on selected tab
        function updateCustomRSSVisibility() {
            console.log('updateCustomRSSVisibility called, currentSearchType:', currentSearchType);
            const customBuilder = document.getElementById('custom-rss-builder');
            const resultsContainer = document.querySelector('.results-container');
            
            console.log('customBuilder found:', !!customBuilder);
            console.log('resultsContainer found:', !!resultsContainer);
            
            if (currentSearchType === 'custom') {
                if (customBuilder) {
                    console.log('Setting customBuilder to block');
                    customBuilder.style.display = 'block';
                    // Initialize if first time
                    const canvas = document.getElementById('rss-canvas');
                    if (canvas && canvas.children.length === 0) {
                        console.log('Initializing palette');
                        initializePalette();
                    }
                }
                if (resultsContainer) {
                    console.log('Hiding results container');
                    resultsContainer.style.display = 'none';
                }
            } else {
                if (customBuilder) {
                    console.log('Hiding custom builder');
                    customBuilder.style.display = 'none';
                }
                if (resultsContainer) {
                    console.log('Showing results container');
                    resultsContainer.style.display = 'block';
                }
            }
        }

        // Canvas transform function
        function updateCanvasTransform() {
            if (canvas) {
                canvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${canvasScale})`;
                canvas.style.transformOrigin = '0 0';
            }
        }

        // Zoom Functions
        function updateZoom() {
            updateCanvasTransform();
            
            // Update zoom level display
            const zoomDisplay = document.getElementById('zoom-level');
            if (zoomDisplay) {
                zoomDisplay.textContent = `${Math.round(canvasScale * 100)}%`;
            }
        }

        function zoomIn() {
            if (canvasScale < maxZoom) {
                canvasScale = Math.min(maxZoom, canvasScale + zoomStep);
                updateZoom();
            }
        }

        function zoomOut() {
            if (canvasScale > minZoom) {
                canvasScale = Math.max(minZoom, canvasScale - zoomStep);
                updateZoom();
            }
        }

        function resetZoom() {
            canvasScale = 1;
            canvasOffset = { x: 0, y: 0 };
            updateZoom();
        }

        function addZoomEventListeners() {
            if (canvas) {
                // Mouse wheel zoom
                canvas.addEventListener('wheel', function(e) {
                    e.preventDefault();
                    
                    if (e.deltaY < 0) {
                        zoomIn();
                    } else {
                        zoomOut();
                    }
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', function(e) {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === '=' || e.key === '+') {
                            e.preventDefault();
                            zoomIn();
                        } else if (e.key === '-') {
                            e.preventDefault();
                            zoomOut();
                        } else if (e.key === '0') {
                            e.preventDefault();
                            resetZoom();
                        }
                    }
                });
            }
        }

        // Initialize the page
        initializePage();
        
        // Initialize zoom functionality
        if (canvas) {
            addZoomEventListeners();
            updateZoom();
        }
</script>